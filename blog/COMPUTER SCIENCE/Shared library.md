#unread

A **shared library** or **shared object** is a file that is intended to be shared by [executable files](https://en.wikipedia.org/wiki/Executable_files "Executable files") and further shared [object files](https://en.wikipedia.org/wiki/Object_file "Object file"). Modules used by a program are loaded from individual shared objects into memory at [load time](https://en.wikipedia.org/wiki/Load_time "Load time") or [runtime](https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase) "Runtime (program lifecycle phase)"), rather than being copied by a linker when it creates a single monolithic executable file for the program.

Shared libraries can be statically linked during compile-time, meaning that references to the library modules are resolved and the modules are allocated memory when the executable file is created.[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_] But often linking of shared libraries is postponed until they are loaded.[_[dubious](https://en.wikipedia.org/wiki/Wikipedia:Accuracy_dispute#Disputed_statement "Wikipedia:Accuracy dispute") – [discuss](https://en.wikipedia.org/wiki/Talk:Shared_library#Dubious "Talk:Shared library")_]

Most modern [operating systems](https://en.wikipedia.org/wiki/Operating_system "Operating system")[[NB 1]](https://en.wikipedia.org/wiki/Shared_library#cite_note-1) can have shared library files of the same format as the executable files. This offers two main advantages: first, it requires making only one loader for both of them, rather than two (having the single loader is considered well worth its added complexity)[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_]. Secondly, it allows the executables also to be used as shared libraries, if they have a [symbol table](https://en.wikipedia.org/wiki/Symbol_table "Symbol table"). Typical combined executable and shared library formats are [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format "Executable and Linkable Format") and [Mach-O](https://en.wikipedia.org/wiki/Mach-O "Mach-O") (both in Unix) and [PE](https://en.wikipedia.org/wiki/Portable_Executable "Portable Executable") (Windows).

In some older environments such as [16-bit Windows](https://en.wikipedia.org/wiki/16-bit_Windows "16-bit Windows") or [MPE](https://en.wikipedia.org/wiki/HP_Multi-Programming_Executive "HP Multi-Programming Executive") for the [HP 3000](https://en.wikipedia.org/wiki/HP_3000 "HP 3000"), only stack-based data (local) was allowed in shared-library code, or other significant restrictions were placed on shared-library code.

## Memory sharing[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=1 "Edit section: Memory sharing")]

Main article: [Shared memory](https://en.wikipedia.org/wiki/Shared_memory "Shared memory")

Library code may be shared in memory by multiple [processes](https://en.wikipedia.org/wiki/Process_(computing) "Process (computing)"), and on disk. If virtual memory is used, processes would execute the same physical page of RAM that is mapped into the different address spaces of the processes. This has advantages. For instance, on the [OpenStep](https://en.wikipedia.org/wiki/OpenStep "OpenStep") system, applications were often only a few hundred kilobytes in size and loaded quickly; most of their code was located in libraries that had already been loaded for other purposes by the operating system.[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_]

Programs can accomplish RAM sharing by using [position-independent code](https://en.wikipedia.org/wiki/Position-independent_code "Position-independent code"), as in [Unix](https://en.wikipedia.org/wiki/Unix "Unix"), which leads to a complex but flexible architecture, or by using common virtual addresses, as in Windows and [OS/2](https://en.wikipedia.org/wiki/OS/2 "OS/2"). These systems ensure, by various means, like pre-mapping the address space and reserving slots for each shared library, that code has a high probability of being shared. A third alternative is [single-level store](https://en.wikipedia.org/wiki/Single-level_store "Single-level store"), as used by the [IBM System/38](https://en.wikipedia.org/wiki/IBM_System/38 "IBM System/38") and its successors. This allows position-dependent code, but places no significant restrictions on where code can be placed or how it can be shared.

In some cases, different versions of shared libraries can cause problems, especially when libraries of different versions have the same file name, and different applications installed on a system each require a specific version. Such a scenario is known as [DLL hell](https://en.wikipedia.org/wiki/DLL_hell "DLL hell"), named after the Windows and OS/2 [DLL file](https://en.wikipedia.org/wiki/DLL_file "DLL file"). Most modern operating systems after 2001 have clean-up methods to eliminate such situations or use application-specific "private" libraries.[[1]](https://en.wikipedia.org/wiki/Shared_library#cite_note-endofdllhell-2)

## Dynamic linking[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=2 "Edit section: Dynamic linking")]

Main article: [Dynamic linker](https://en.wikipedia.org/wiki/Dynamic_linker "Dynamic linker")

Dynamic linking or [late binding](https://en.wikipedia.org/wiki/Late_binding "Late binding") is linking performed while a program is being loaded ([load time](https://en.wikipedia.org/wiki/Load_time "Load time")) or executed ([runtime](https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase) "Runtime (program lifecycle phase)")), rather than when the executable file is created. A dynamically linked library ([dynamic-link library](https://en.wikipedia.org/wiki/Dynamic-link_library "Dynamic-link library"), or DLL, under [Windows](https://en.wikipedia.org/wiki/Microsoft_Windows "Microsoft Windows") and [OS/2](https://en.wikipedia.org/wiki/OS/2 "OS/2"); shareable image under [OpenVMS](https://en.wikipedia.org/wiki/OpenVMS "OpenVMS");[[2]](https://en.wikipedia.org/wiki/Shared_library#cite_note-3) dynamic shared object, or DSO, under [Unix-like](https://en.wikipedia.org/wiki/Unix-like "Unix-like") systems) is a library intended for dynamic linking. Only a minimal amount of work is done by the [linker](https://en.wikipedia.org/wiki/Linker_(computing) "Linker (computing)") when the executable file is created; it only records what library routines the program needs and the index names or numbers of the routines in the library. The majority of the work of linking is done at the time the application is loaded (load time) or during execution (runtime). Usually, the necessary linking program, called a "dynamic linker" or "linking loader", is actually part of the underlying [operating system](https://en.wikipedia.org/wiki/Operating_system "Operating system"). (However, it is possible, and not exceedingly difficult, to write a program that uses dynamic linking and includes its own dynamic linker, even for an operating system that itself provides no support for dynamic linking.)

Programmers originally developed dynamic linking in the [Multics](https://en.wikipedia.org/wiki/Multics "Multics") operating system, starting in 1964, and the MTS ([Michigan Terminal System](https://en.wikipedia.org/wiki/Michigan_Terminal_System "Michigan Terminal System")), built in the late 1960s.[[3]](https://en.wikipedia.org/wiki/Shared_library#cite_note-4)

## Optimizations[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=3 "Edit section: Optimizations")]

Since shared libraries on most systems do not change often, systems can compute a likely load address for each shared library on the system before it is needed and store that information in the libraries and executables. If every shared library that is loaded has undergone this process, then each will load at its predetermined address, which speeds up the process of dynamic linking. This optimization is known as [prebinding or prelinking](https://en.wikipedia.org/wiki/Prebinding "Prebinding") on macOS and Linux, respectively. IBM [z/VM](https://en.wikipedia.org/wiki/Z/VM "Z/VM") uses a similar technique, called "Discontinuous Saved Segments" (DCSS).[[4]](https://en.wikipedia.org/wiki/Shared_library#cite_note-5) Disadvantages of this technique include the time required to precompute these addresses every time the shared libraries change, the inability to use [address space layout randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization "Address space layout randomization"), and the requirement of sufficient virtual address space for use (a problem that will be alleviated by the adoption of [64-bit](https://en.wikipedia.org/wiki/64-bit "64-bit") architectures, at least for the time being).

## Locating libraries at runtime[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=4 "Edit section: Locating libraries at runtime")]

Loaders for shared libraries vary widely in functionality. Some depend on the executable storing explicit paths to the libraries. Any change to the library naming or layout of the file system will cause these systems to fail. More commonly, only the name of the library (and not the path) is stored in the executable, with the operating system supplying a method to find the library on disk, based on some algorithm.

If a shared library that an executable depends on is deleted, moved, or renamed, or if an incompatible version of the library is copied to a place that is earlier in the search, the executable would fail to load. This is called _[dependency hell](https://en.wikipedia.org/wiki/Dependency_hell "Dependency hell")_, existing on many platforms. The (infamous) Windows variant is commonly known as [DLL hell](https://en.wikipedia.org/wiki/DLL_hell "DLL hell"). This problem cannot occur if each version of each library is uniquely identified and each program references libraries only by their full unique identifiers. The "DLL hell" problems with earlier Windows versions arose from using only the names of libraries, which were not guaranteed to be unique, to resolve dynamic links in programs. (To avoid "DLL hell", later versions of Windows rely largely on options for programs to install private DLLs—essentially a partial retreat from the use of shared libraries—along with mechanisms to prevent replacement of shared system DLLs with earlier versions of them.)

### Microsoft Windows[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=5 "Edit section: Microsoft Windows")]

[Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows "Microsoft Windows") checks the [registry](https://en.wikipedia.org/wiki/Windows_registry "Windows registry") to determine the proper place to load DLLs that implement [COM objects](https://en.wikipedia.org/wiki/Component_Object_Model "Component Object Model"), but for other DLLs it will check the directories in a defined order. First, Windows checks the directory where it loaded the program (_private DLL_[[1]](https://en.wikipedia.org/wiki/Shared_library#cite_note-endofdllhell-2)); any directories set by calling the `SetDllDirectory()` function; the System32, System, and Windows directories; then the current working directory; and finally the directories specified by the PATH [environment variable](https://en.wikipedia.org/wiki/Environment_variable "Environment variable").[[5]](https://en.wikipedia.org/wiki/Shared_library#cite_note-6) Applications written for the [.NET Framework](https://en.wikipedia.org/wiki/.NET_Framework ".NET Framework") (since 2002), also check the [Global Assembly Cache](https://en.wikipedia.org/wiki/Global_Assembly_Cache "Global Assembly Cache") as the primary store of shared dll files to remove the issue of [DLL hell](https://en.wikipedia.org/wiki/DLL_hell "DLL hell").

### OpenStep[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=6 "Edit section: OpenStep")]

[OpenStep](https://en.wikipedia.org/wiki/OpenStep "OpenStep") used a more flexible system, collecting a list of libraries from a number of known locations (similar to the PATH concept) when the system first starts. Moving libraries around causes no problems at all, although users incur a time cost when first starting the system.

### Unix-like systems[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=7 "Edit section: Unix-like systems")]

Most [Unix-like](https://en.wikipedia.org/wiki/Unix-like "Unix-like") systems have a "search path" specifying file-system [directories](https://en.wikipedia.org/wiki/Directory_(computing) "Directory (computing)") in which to look for dynamic libraries. Some systems specify the default path in a [configuration file](https://en.wikipedia.org/wiki/Configuration_file "Configuration file"), others hard-code it into the dynamic loader. Some [executable file](https://en.wikipedia.org/wiki/Executable "Executable") formats can specify additional directories in which to search for libraries for a particular program. This can usually be overridden with an [environment variable](https://en.wikipedia.org/wiki/Environment_variable "Environment variable"), although it is disabled for [setuid](https://en.wikipedia.org/wiki/Setuid "Setuid") and setgid programs, so that a user can't force such a program to run arbitrary code with root permissions. Developers of libraries are encouraged to place their dynamic libraries in places in the default search path. On the downside, this can make installation of new libraries problematic, and these "known" locations quickly become home to an increasing number of library files, making management more complex.

## Dynamic loading[[edit](https://en.wikipedia.org/w/index.php?title=Shared_library&action=edit&section=8 "Edit section: Dynamic loading")]

Main article: [Dynamic loading](https://en.wikipedia.org/wiki/Dynamic_loading "Dynamic loading")

Dynamic loading, a subset of dynamic linking, involves a dynamically linked library loading and unloading at [runtime](https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase) "Runtime (program lifecycle phase)") on request. Such a request may be made implicitly or explicitly. Implicit requests are made when a compiler or static linker adds library references that include file paths or simply file names.[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_] Explicit requests are made when applications make direct calls to an operating system's API.

Most operating systems that support dynamically linked libraries also support dynamically loading such libraries via a [run-time](https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase) "Runtime (program lifecycle phase)") linker [API](https://en.wikipedia.org/wiki/Application_programming_interface "Application programming interface"). For instance, [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows "Microsoft Windows") uses the API functions `LoadLibrary`, `LoadLibraryEx`, `FreeLibrary` and `GetProcAddress` with [Microsoft Dynamic Link Libraries](https://en.wikipedia.org/wiki/Microsoft_Dynamic_Link_Library "Microsoft Dynamic Link Library"); [POSIX](https://en.wikipedia.org/wiki/POSIX "POSIX")-based systems, including most UNIX and UNIX-like systems, use `dlopen`, `dlclose` and `dlsym`. Some development systems automate this process.